<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>零宽字符 编码 / 解码</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
        rel="stylesheet">
  <style>
    /* 让隐藏的文本在复制时仍然全部被选中 */
    .zw-output { user-select: all; }
  </style>
</head>
<body class="bg-light py-4">
<div class="container">

  <h2 class="mb-4">零宽字符 编码 &amp; 解码</h2>

  <!-- 输入区 -->
  <div class="mb-3">
    <label class="form-label">原始文本</label>
    <textarea id="plain" class="form-control" rows="3"
            placeholder="在此输入要转换的文字…"></textarea>
  </div>

  <button id="encodeBtn" class="btn btn-primary me-2">编码为零宽字符</button>
  <button id="decodeBtn" class="btn btn-success">解码回可读文字</button>

  <!-- 输出区 -->
  <div class="mt-4">
    <label class="form-label">结果</label>
    <textarea id="result" class="form-control zw-output" rows="3"
              readonly></textarea>
  </div>

  <div id="msg" class="mt-3 fw-medium"></div>
</div>

<script>
/* ---------- 零宽字符映射 ---------- */
const ZW_ZERO = '\u200b'; // 0
const ZW_ONE  = '\u200c'; // 1

function bytesToZeroWidth(bytes) {
  // 把每个字节转成 8 位二进制，再映射为零宽字符
  let bits = '';
  for (const b of bytes) bits += b.toString(2).padStart(8, '0');
  return bits.split('').map(bit => bit === '0' ? '' : '').join(''); // placeholder
}

// 正确实现（避免上面占位错误）
function encodeToZeroWidth(str) {
  const encoder = new TextEncoder();               // UTF‑8 编码
  const bytes = encoder.encode(str);
  let bits = '';
  for (const b of bytes) bits += b.toString(2).padStart(8, '0');
  return bits.split('').map(bit => bit === '0' ? ZW_ZERO : ZW_ONE).join('');
}

function decodeFromZeroWidth(zwStr) {
  // 只保留零宽字符，忽略可能的其它字符
  const filtered = Array.from(zwStr).filter(c => c === ZW_ZERO || c === ZW_ONE);
  const bits = filtered.map(c => c === ZW_ZERO ? '0' : '1').join('');
  if (bits.length % 8 !== 0) return null; // 长度不合法

  const bytes = new Uint8Array(bits.length / 8);
  for (let i = 0; i < bits.length; i += 8) {
    bytes[i / 8] = parseInt(bits.slice(i, i + 8), // placeholder
  // Actually implement correctly below
}

// Proper decode implementation
function decodeFromZeroWidth(zwStr) {
  const filtered = Array.from(zwStr).filter(c => c === ZW_ZERO || c === ZW_ONE);
  const bits = filtered.map(c => c === ZW_ZERO ? '0' : '1').join('');
  if (bits.length % 8 !== 0) return null;

  const byteArr = new Uint8Array(bits.length / 8);
  for (let i = 0; i < bits.length; i += 8) {
    byteArr[i / 8] = parseInt(bits.slice(i, i + 8), 2);
  }
  const decoder = new TextDecoder(); // UTF‑8 解码
  return decoder.decode(byteArr);
}

/* ---------- 交互逻辑 ---------- */
document.getElementById('encodeBtn').addEventListener('click', () => {
  const txt = document.getElementById('plain').value;
  if (!txt) return;
  const zw = encodeToZeroWidth(txt);
  document.getElementById('result').value = zw;
  document.getElementById('msg').textContent = '已转为零宽字符（不可见）。可复制后粘贴到任意文本框。';
});

document.getElementById('decodeBtn').addEventListener('click', () => {
  const zw = document.getElementById('result').value;
  if (!zw) return;
  const decoded = decodeFromZeroWidth(zw);
  if (decoded === null) {
    document.getElementById('msg').textContent = '❌ 解码失败：零宽字符长度不合法。';
    return;
  }
  document.getElementById('plain').value = decoded;
  document.getElementById('msg').textContent = '✅ 已恢复为可读文字。';
});
</script>
</body>
</html>
