// src/main.rs
use actix_files::NamedFile;
use actix_multipart::Multipart;
use actix_web::{
    delete, get, post, put,
    web::{self, Data, Json, Path, Query},
    App, Error, HttpResponse, HttpServer, Responder, Result,
};
use futures_util::StreamExt as _;
use serde::{Deserialize, Serialize};
use std::path::{Component, Path as StdPath, PathBuf};
use tokio::fs;
use walkdir::WalkDir;

#[derive(Clone)]
struct AppState {
    root: PathBuf,
}

#[derive(Serialize)]
struct Entry {
    path: String,
    name: String,
    is_dir: bool,
    size: u64,
}

fn sanitize_relative(p: &str) -> Option<PathBuf> {
    let pb = PathBuf::from(p);
    if pb.is_absolute() {
        return None;
    }
    for c in pb.components() {
        match c {
            Component::ParentDir => return None,
            Component::Prefix(_) | Component::RootDir => return None,
            _ => {}
        }
    }
    Some(pb)
}

#[post("/upload/{dest:.*}")]
async fn upload(
    state: Data<AppState>,
    path: Path<String>,
    mut payload: Multipart,
) -> Result<impl Responder, Error> {
    let dest = path.into_inner();
    let dest = if dest.is_empty() { "." } else { &dest };
    let dest = sanitize_relative(dest).ok_or_else(|| actix_web::error::ErrorBadRequest("invalid dest"))?;
    let dest_abs = state.root.join(dest);
    fs::create_dir_all(&dest_abs).await.map_err(actix_web::error::ErrorInternalServerError)?;

    while let Some(field) = payload.next().await {
        let mut field = field?;
        let filename = field
            .content_disposition()
            .and_then(|cd| cd.get_filename().map(|s| s.to_string()))
            .ok_or_else(|| actix_web::error::ErrorBadRequest("no filename"))?;
        let filename = sanitize_relative(&filename).ok_or_else(|| actix_web::error::ErrorBadRequest("invalid filename"))?;
        let filepath = dest_abs.join(filename);
        if let Some(p) = filepath.parent() {
            fs::create_dir_all(p).await.map_err(actix_web::error::ErrorInternalServerError)?;
        }
        let mut f = fs::File::create(&filepath).await.map_err(actix_web::error::ErrorInternalServerError)?;
        while let Some(chunk) = field.next().await {
            let data = chunk?;
            tokio::io::AsyncWriteExt::write_all(&mut f, &data)
                .await
                .map_err(actix_web::error::ErrorInternalServerError)?;
        }
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({"ok": true})))
}

#[get("/download/{req_path:.*}")]
async fn download(state: Data<AppState>, req_path: Path<String>) -> Result<NamedFile> {
    let rel = req_path.into_inner();
    let rel = if rel.is_empty() { "." } else { &rel };
    let rel = sanitize_relative(rel).ok_or_else(|| actix_web::error::ErrorBadRequest("invalid"))?;
    let abs = state.root.join(rel).canonicalize().map_err(|_| actix_web::error::ErrorNotFound("not found"))?;
    if !abs.starts_with(&state.root) {
        return Err(actix_web::error::ErrorForbidden("outside root"));
    }
    let md = fs::metadata(&abs).await.map_err(|_| actix_web::error::ErrorNotFound("not found"))?;
    if md.is_dir() {
        return Err(actix_web::error::ErrorBadRequest("is directory"));
    }
    Ok(NamedFile::open_async(abs).await?)
}

#[derive(Deserialize)]
struct ListQuery {
    recursive: Option<bool>,
}

#[get("/api/list/{req_path:.*}")]
async fn list(
    state: Data<AppState>,
    req_path: Path<String>,
    q: Query<ListQuery>,
) -> Result<Json<Vec<Entry>>> {
    let rel = req_path.into_inner();
    let rel = if rel.is_empty() { "." } else { &rel };
    let rel = sanitize_relative(rel).ok_or_else(|| actix_web::error::ErrorBadRequest("invalid"))?;
    let abs = state.root.join(rel).canonicalize().map_err(|_| actix_web::error::ErrorNotFound("not found"))?;
    if !abs.starts_with(&state.root) {
        return Err(actix_web::error::ErrorForbidden("outside"));
    }
    let mut entries = Vec::new();
    let recursive = q.recursive.unwrap_or(false);
    if recursive {
        for entry in WalkDir::new(&abs) {
            let entry = entry.map_err(|_| actix_web::error::ErrorInternalServerError("walk"))?;
            let p = entry.path();
            let meta = fs::metadata(p).await.map_err(|_| actix_web::error::ErrorInternalServerError("meta"))?;
            let relp = p.strip_prefix(&state.root).map_err(|_| actix_web::error::ErrorInternalServerError("strip"))?;
            entries.push(Entry {
                path: relp.to_string_lossy().to_string(),
                name: p.file_name().map(|s| s.to_string_lossy().to_string()).unwrap_or_else(|| "".into()),
                is_dir: meta.is_dir(),
                size: if meta.is_file() { meta.len() } else { 0 },
            });
        }
    } else {
        let mut rd = fs::read_dir(&abs).await.map_err(|_| actix_web::error::ErrorNotFound("not found"))?;
        while let Some(ent) = rd.next_entry().await.map_err(|_| actix_web::error::ErrorInternalServerError("read_dir"))? {
            let p = ent.path();
            let meta = ent.metadata().await.map_err(|_| actix_web::error::ErrorInternalServerError("meta"))?;
            let relp = p.strip_prefix(&state.root).map_err(|_| actix_web::error::ErrorInternalServerError("strip"))?;
            entries.push(Entry {
                path: relp.to_string_lossy().to_string(),
                name: p.file_name().map(|s| s.to_string_lossy().to_string()).unwrap_or_else(|| "".into()),
                is_dir: meta.is_dir(),
                size: if meta.is_file() { meta.len() } else { 0 },
            });
        }
    }
    Ok(Json(entries))
}

#[derive(Deserialize)]
struct MkdirBody {
    path: String,
}

#[post("/api/mkdir")]
async fn mkdir(state: Data<AppState>, j: Json<MkdirBody>) -> Result<impl Responder> {
    let rel = sanitize_relative(&j.path).ok_or_else(|| actix_web::error::ErrorBadRequest("invalid"))?;
    let abs = state.root.join(rel);
    fs::create_dir_all(&abs).await.map_err(actix_web::error::ErrorInternalServerError)?;
    Ok(HttpResponse::Ok().json(serde_json::json!({"ok": true})))
}

#[derive(Deserialize)]
struct RenameBody {
    src: String,
    dst: String,
}

#[put("/api/move")]
async fn movep(state: Data<AppState>, j: Json<RenameBody>) -> Result<impl Responder> {
    let src = sanitize_relative(&j.src).ok_or_else(|| actix_web::error::ErrorBadRequest("invalid src"))?;
    let dst = sanitize_relative(&j.dst).ok_or_else(|| actix_web::error::ErrorBadRequest("invalid dst"))?;
    let abs_src = state.root.join(&src).canonicalize().map_err(|_| actix_web::error::ErrorNotFound("src not"))?;
    let abs_dst_parent = state.root.join(&dst).parent().map(|p| p.to_path_buf()).ok_or_else(|| actix_web::error::ErrorBadRequest("bad dst"))?;
    if !abs_src.starts_with(&state.root) || !abs_dst_parent.starts_with(&state.root) {
        return Err(actix_web::error::ErrorForbidden("outside"));
    }
    fs::create_dir_all(&abs_dst_parent).await.map_err(|_| actix_web::error::ErrorInternalServerError("mkparent"))?;
    let abs_dst = state.root.join(&dst);
    fs::rename(&abs_src, &abs_dst).await.map_err(|e| actix_web::error::ErrorInternalServerError(format!("rename: {}", e)))?;
    Ok(HttpResponse::Ok().json(serde_json::json!({"ok": true})))
}

#[derive(Deserialize)]
struct DeleteBody {
    path: String,
}

#[delete("/api/delete")]
async fn deletep(state: Data<AppState>, j: Json<DeleteBody>) -> Result<impl Responder> {
    let rel = sanitize_relative(&j.path).ok_or_else(|| actix_web::error::ErrorBadRequest("invalid"))?;
    let abs = state.root.join(rel).canonicalize().map_err(|_| actix_web::error::ErrorNotFound("not found"))?;
    if !abs.starts_with(&state.root) {
        return Err(actix_web::error::ErrorForbidden("outside"));
    }
    let md = fs::metadata(&abs).await.map_err(|_| actix_web::error::ErrorNotFound("not found"))?;
    if md.is_dir() {
        fs::remove_dir_all(&abs).await.map_err(|_| actix_web::error::ErrorInternalServerError("rmdir"))?;
    } else {
        fs::remove_file(&abs).await.map_err(|_| actix_web::error::ErrorInternalServerError("rmfile"))?;
    }
    Ok(HttpResponse::Ok().json(serde_json::json!({"ok": true})))
}

#[get("/")]
async fn index() -> Result<NamedFile> {
    Ok(NamedFile::open_async("./static/index.html").await?)
}

async fn ensure_static_files() -> std::io::Result<()> {
    // create static dir if missing and write index.html, app.js, style.css if they don't exist
    fs::create_dir_all("./static").await?;
    // index.html
    if fs::metadata("./static/index.html").await.is_err() {
        let html = r#"<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>File Store</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
<div class="container py-4">
  <h1 class="mb-3">File Store</h1>

  <div class="mb-3">
    <div id="dropzone" class="border rounded p-3 bg-light">
      <div><strong>Drag files here</strong> or click to select files to upload.</div>
      <input id="file-input" type="file" multiple style="display:none;">
      <div class="mt-2">
        <button id="btn-upload" class="btn btn-primary btn-sm">Upload selected</button>
        <button id="btn-refresh" class="btn btn-secondary btn-sm">Refresh</button>
        <button id="btn-mkfolder" class="btn btn-outline-secondary btn-sm">New Folder</button>
      </div>
      <div id="selected-list" class="mt-2"></div>
    </div>
  </div>

  <nav aria-label="breadcrumb">
    <ol class="breadcrumb" id="breadcrumb"></ol>
  </nav>

  <div class="mb-3">
    <ul id="entries" class="list-group"></ul>
  </div>

  <div class="mt-3">
    <small class="text-muted">Click file name to download. Drag entries to move (experimental).</small>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="/static/app.js"></script>
</body>
</html>
"#;
        fs::write("./static/index.html", html).await?;
    }
    // style.css
    if fs::metadata("./static/style.css").await.is_err() {
        let css = r#"#dropzone {
  min-height: 120px;
  cursor: pointer;
}
#dropzone.dragover {
  background: #e9f7ef;
  border-color: #0d6efd;
}
.list-group-item .entry-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.entry-meta {
  color: #6c757d;
  font-size: 0.9rem;
}
.entry-actions button {
  margin-left: 6px;
}
.drag-handle {
  cursor: grab;
}
"#;
        fs::write("./static/style.css", css).await?;
    }
    // app.js
    if fs::metadata("./static/app.js").await.is_err() {
        let js = r#"const apiBase = "";
let cwd = "."; // relative path within root
let selectedFiles = [];

const fileInput = document.getElementById("file-input");
const dropzone = document.getElementById("dropzone");
const selectedList = document.getElementById("selected-list");
const entriesEl = document.getElementById("entries");
const breadcrumb = document.getElementById("breadcrumb");

dropzone.addEventListener("click", ()=> fileInput.click());
fileInput.addEventListener("change", (e)=>{
  selectedFiles = Array.from(e.target.files);
  renderSelected();
});

dropzone.addEventListener("dragover", (e)=>{
  e.preventDefault();
  dropzone.classList.add("dragover");
});
dropzone.addEventListener("dragleave", (e)=>{
  dropzone.classList.remove("dragover");
});
dropzone.addEventListener("drop", (e)=>{
  e.preventDefault();
  dropzone.classList.remove("dragover");
  const dt = e.dataTransfer;
  if (dt && dt.files) {
    selectedFiles = selectedFiles.concat(Array.from(dt.files));
    renderSelected();
  }
});

document.getElementById("btn-upload").addEventListener("click", uploadSelected);
document.getElementById("btn-refresh").addEventListener("click", ()=> loadEntries(cwd));
document.getElementById("btn-mkfolder").addEventListener("click", async ()=>{
  const name = prompt("Folder name:");
  if (!name) return;
  const path = joinPath(cwd, name);
  await fetch(`/api/mkdir`, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({path})});
  loadEntries(cwd);
});

function renderSelected(){
  selectedList.innerHTML = "";
  selectedFiles.forEach((f,i)=>{
    const div = document.createElement("div");
    div.textContent = `${f.name} (${Math.round(f.size/1024)} KB)`;
    const btn = document.createElement("button");
    btn.className = "btn btn-sm btn-outline-danger ms-2";
    btn.textContent = "x";
    btn.addEventListener("click", ()=> { selectedFiles.splice(i,1); renderSelected(); });
    div.appendChild(btn);
    selectedList.appendChild(div);
  });
}

async function uploadSelected(){
  if (!selectedFiles.length) return alert("No files selected");
  const form = new FormData();
  selectedFiles.forEach(f => form.append("file", f, f.name));
  const resp = await fetch(`/upload/${encodeURIComponent(cwd)}`, {method:"POST", body: form});
  if (resp.ok) {
    selectedFiles = [];
    fileInput.value = "";
    renderSelected();
    loadEntries(cwd);
  } else {
    alert("Upload failed");
  }
}

function joinPath(base, name) {
  if (base === "." || base === "") return name;
  return base.replace(/\/+$/,"") + "/" + name.replace(/^\/+/,"");
}

async function loadEntries(dir) {
  cwd = dir || ".";
  const resp = await fetch(`/api/list/${encodeURIComponent(cwd)}`);
  if (!resp.ok) return;
  const items = await resp.json();
  renderBreadcrumb(cwd);
  entriesEl.innerHTML = "";
  // sort: dirs first
  items.sort((a,b)=> (b.is_dir - a.is_dir) || a.name.localeCompare(b.name));
  items.forEach(it=>{
    const li = document.createElement("li");
    li.className = "list-group-item";
    const row = document.createElement("div"); row.className = "entry-row";
    const left = document.createElement("div");
    const ico = document.createElement("span");
    ico.className = it.is_dir ? "bi-folder-fill me-2" : "bi-file-earmark-fill me-2";
    ico.textContent = it.is_dir ? "ðŸ“" : "ðŸ“„";
    const name = document.createElement("a");
    name.href = it.is_dir ? "#" : `/download/${encodeURIComponent(it.path)}`;
    name.textContent = it.name || it.path;
    if (it.is_dir) {
      name.addEventListener("click",(e)=>{ e.preventDefault(); loadEntries(it.path); });
    }
    left.appendChild(ico); left.appendChild(name);
    const right = document.createElement("div");
    right.className = "entry-actions";
    const meta = document.createElement("span"); meta.className="entry-meta";
    meta.textContent = it.is_dir ? "Folder" : `${Math.round(it.size/1024)} KB`;
    right.appendChild(meta);
    const renameBtn = document.createElement("button"); renameBtn.className="btn btn-sm btn-outline-secondary ms-2";
    renameBtn.textContent = "Rename/Move";
    renameBtn.addEventListener("click", async ()=>{
      const dst = prompt("New path (relative to root):", it.path);
      if (!dst) return;
      const r = await fetch(`/api/move`, {method:"PUT", headers:{"Content-Type":"application/json"}, body: JSON.stringify({src: it.path, dst})});
      if (r.ok) loadEntries(cwd); else alert("Move failed");
    });
    const delBtn = document.createElement("button"); delBtn.className="btn btn-sm btn-outline-danger ms-2";
    delBtn.textContent = "Delete";
    delBtn.addEventListener("click", async ()=>{
      if (!confirm("Delete?")) return;
      const r = await fetch(`/api/delete`, {method:"DELETE", headers:{"Content-Type":"application/json"}, body: JSON.stringify({path: it.path})});
      if (r.ok) loadEntries(cwd); else alert("Delete failed");
    });
    right.appendChild(renameBtn); right.appendChild(delBtn);

    row.appendChild(left); row.appendChild(right);
    li.appendChild(row);
    entriesEl.appendChild(li);
  });

  // enable dropping onto folder list items
  Array.from(entriesEl.children).forEach(li=>{
    li.addEventListener("dragstart", (e)=>{ 
      const a = li.querySelector("a");
      if (!a) return;
      e.dataTransfer.setData("text/plain", a.href);
    });
  });

  Array.from(entriesEl.children).forEach(li=>{
    const anchor = li.querySelector("a");
    const isDir = anchor && anchor.getAttribute("href") === "#";
    if (isDir) {
      li.addEventListener("dragover", (e)=>{ e.preventDefault(); li.classList.add("dragover"); });
      li.addEventListener("dragleave", ()=> li.classList.remove("dragover"));
      li.addEventListener("drop", async (e)=>{
        e.preventDefault(); li.classList.remove("dragover");
        alert("Use Rename/Move button to move entries (drag-move experimental).");
      });
    }
  });
}

function renderBreadcrumb(path) {
  const parts = path === "." ? [] : path.split("/").filter(Boolean);
  breadcrumb.innerHTML = "";
  const liRoot = document.createElement("li"); liRoot.className="breadcrumb-item";
  const aRoot = document.createElement("a"); aRoot.href="#"; aRoot.textContent="root";
  aRoot.addEventListener("click",(e)=>{ e.preventDefault(); loadEntries("."); });
  liRoot.appendChild(aRoot);
  breadcrumb.appendChild(liRoot);
  let acc = "";
  parts.forEach((p,i)=>{
    acc = i===0 ? p : acc + "/" + p;
    const li = document.createElement("li"); li.className="breadcrumb-item";
    const a = document.createElement("a"); a.href="#"; a.textContent=p;
    a.addEventListener("click",(e)=>{ e.preventDefault(); loadEntries(acc); });
    li.appendChild(a);
    breadcrumb.appendChild(li);
  });
}

loadEntries(".");
"#;
        fs::write("./static/app.js", js).await?;
    }
    Ok(())
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // ensure static files exist (create if missing)
    ensure_static_files().await.expect("create static files");

    let root = std::env::args().nth(1).unwrap_or_else(|| "./storage".into());
    let rootp = PathBuf::from(root);
    fs::create_dir_all(&rootp).await.expect("create root");
    let rootp = rootp.canonicalize().expect("canonicalize root");
    let state = Data::new(AppState { root: rootp });

    println!("Server running at http://127.0.0.1:8080/");
    HttpServer::new(move || {
        App::new()
            .app_data(state.clone())
            .service(upload)
            .service(download)
            .service(list)
            .service(mkdir)
            .service(movep)
            .service(deletep)
            .service(index)
            .service(actix_files::Files::new("/static", "./static").show_files_listing().use_last_modified(true))
    })
    .bind(("127.0.0.1", 8080))?
    .run()
    .await
}
